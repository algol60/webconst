<!DOCTYPE html>
<html>

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="icon" href="constellation.png">
    <title>Babylon graph from JSON</title>

    <style>
      html, body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }
    </style>

    <script src="js/babylon-4.1.0.js"></script>
  </head>

  <body>

  <canvas id="renderCanvas" touch-action="none"></canvas> //touch-action="none" for best results from PEP

  <script>
    'use strict';

    const canvas = document.getElementById('renderCanvas'); // Get the canvas element
    const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
    console.log('Maximum texture size:', engine.getCaps().maxTextureSize);

    const createScene = function () {

      // scene and lights
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3(0x1b/255, 0x1e/255, 0x24/255);
      const camera = new BABYLON.ArcRotateCamera('camera1', 0, 0, 0, new BABYLON.Vector3(0, 0, -0), scene);
      camera.wheelPrecision = 50;
      camera.setPosition(new BABYLON.Vector3(0, 50, -300));
      camera.attachControl(canvas, true);
      const light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(1, 1, 0), scene);
      light.intensity = 0.9;
      const pl = new BABYLON.PointLight('pl', new BABYLON.Vector3(0, 0, 0), scene);
      // pl.diffuse = new BABYLON.Color3(1, 1, 1);
      // pl.specular = new BABYLON.Color3(0.5, 0.2, 0.2);
      pl.intensity = 0.75;

      fetch('sphere-graph.json')
      .then(response => response.json())
      .then(data => {
        const NVX = Object.keys(data.vertex).length;
        console.log('Vertices: %s', NVX);
        console.log('Atlas   : %s', data.sprite_atlas)

        const spriteMgr = new BABYLON.SpriteManager('vxMgr', data.sprite_atlas, NVX, 256, scene);

        for(let [i, vx] of Object.entries(data.vertex)) {
          const sprite = new BABYLON.Sprite('sprite_'+i, spriteMgr);
          sprite.position.x = vx.x;
          sprite.position.y = vx.y;
          sprite.position.z = -vx.z;
          sprite.cellIndex = vx.cell_index;
          sprite.size = 4.0 * vx.nradius;
        }

        const NTX = data.transaction.length;
        const lines = [];
        const lineColors = [];
        data.transaction.forEach(tx => {
          const s = data.vertex[tx['source.[id]']];
          const d = data.vertex[tx['destination.[id]']];
          const line = [new BABYLON.Vector3(s.x, s.y, -s.z), new BABYLON.Vector3(d.x, d.y, -d.z)];
          lines.push(line);

          const color = new BABYLON.Color4(...tx.color);
          lineColors.push([color, color]);
        });

        const liness = BABYLON.MeshBuilder.CreateLineSystem('liness', {lines: lines, colors:lineColors, useVertexAlpha:false}, scene);
      })
      .catch(error => {console.log('Error:', error);});

      return scene;
    };

    const scene = createScene(); //Call the createScene function

    // Register a render loop to repeatedly render the scene
    engine.runRenderLoop(function () {
            scene.render();
    });

    // Watch for browser/canvas resize events
    window.addEventListener('resize', function () {
            engine.resize();
    });
  </script>
  </body>

</html>