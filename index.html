<!DOCTYPE html>
<html>

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="icon" href="constellation.png">
    <title>Babylon graph from JSON</title>

    <style>
      html, body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }
    </style>

    <script src="js/babylon-4.1.0.js"></script>
    <script src="js/babylon.gui.min.js"></script>
</head>

  <body>

  <canvas id="renderCanvas" touch-action="none"></canvas> //touch-action="none" for best results from PEP

  <script>
    'use strict';

    BABYLON.Effect.ShadersStore['spritesVertexShader'] = `
attribute vec4 position;
attribute vec4 options;
attribute vec2 inverts;
attribute vec4 cellInfo;
attribute vec4 color;

uniform mat4 view;
uniform mat4 projection;

varying vec2 vUV;
varying vec2 bgUV;
varying vec4 vColor;
#include<fogVertexDeclaration>
void main(void) {
  vec3 viewPos = (view*vec4(position.xyz, 1.0)).xyz;
  vec2 cornerPos;
  float angle = position.w;
  vec2 size = vec2(options.x,options.y);
  vec2 offset = options.zw;
  cornerPos = vec2(offset.x-0.5, offset.y-0.5)*size;

  // vec3 rotatedCorner;
  // rotatedCorner.x = cornerPos.x*cos(angle)-cornerPos.y*sin(angle);
  // rotatedCorner.y = cornerPos.x*sin(angle)+cornerPos.y*cos(angle);
  // rotatedCorner.z = 0.;

  vec3 rotatedCorner;
  rotatedCorner.x = cornerPos.x;
  rotatedCorner.y = cornerPos.y;
  rotatedCorner.z = 0.;

  viewPos += rotatedCorner;
  gl_Position = projection*vec4(viewPos,1.0);

  vColor = color;

  vec2 uvOffset = vec2(abs(offset.x-inverts.x), abs(1.0-offset.y-inverts.y));
  vec2 uvPlace = cellInfo.xy;
  vec2 uvSize = cellInfo.zw;
  vUV.x = uvPlace.x+uvSize.x*uvOffset.x;
  vUV.y = uvPlace.y+uvSize.y*uvOffset.y;

  // Extract the background icon position from angle.
  // All of the icons are the same size, so we can reuse size and offset.
  //
  vec2 bgPlace = vec2(trunc(angle)/67108864.0, angle - trunc(angle));
  bgUV.x = bgPlace.x + uvSize.x*uvOffset.x;
  bgUV.y = bgPlace.y + uvSize.y*uvOffset.y;

  #ifdef FOG
  vFogDistance = viewPos;
  #endif
}
  `;

    BABYLON.Effect.ShadersStore['spritesPixelShader']  =  `
uniform bool alphaTest;
varying vec4 vColor;

varying vec2 vUV;
varying vec2 bgUV;
uniform sampler2D diffuseSampler;

#include<fogFragmentDeclaration>

void main(void) {
  vec4 color = texture2D(diffuseSampler, vUV);
  if(true) // (alphaTest)
  {
    if (color.a<0.95)
    {
      vec4 bgColor = texture2D(diffuseSampler,bgUV);
      if(bgColor.a<0.95) discard;
      // bgColor.a = 1.0;
      color = bgColor * vColor;
    }
  }
  // color *= vColor;

  #include<fogFragment>

  gl_FragColor=color;
}
    `;

    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true);
    console.log('Maximum texture size:', engine.getCaps().maxTextureSize);

    const createScene = function () {

      // scene and lights
      const scene = new BABYLON.Scene(engine);
      // scene.clearColor = new BABYLON.Color3(0x1b/255, 0x1e/255, 0x24/255);
      const camera = new BABYLON.ArcRotateCamera('camera1', 0, 0, 0, new BABYLON.Vector3(0, 0, -0), scene);
      camera.wheelPrecision = 50;
      // camera.setPosition(new BABYLON.Vector3(0, 50, -300));

      camera.attachControl(canvas, true);
      scene.activeCamera.panningSensibility = 50;

      const light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(1, 1, 0), scene);
      light.intensity = 0.9;
      const pl = new BABYLON.PointLight('pl', new BABYLON.Vector3(0, 0, 0), scene);
      // pl.diffuse = new BABYLON.Color3(1, 1, 1);
      // pl.specular = new BABYLON.Color3(0.5, 0.2, 0.2);
      pl.intensity = 0.75;

      fetch('sphere-graph.json')
      .then(response => response.json())
      .then(data => {
        const label = new BABYLON.GUI.Rectangle('node label');
        label.isPointerBlocker = false;
        // label.adaptWidthToChildren = true;
        // label.adaptHeightToChildren = true;
        const text1 = new BABYLON.GUI.TextBlock('node text');
        text1.isPointerBlocker = false;
        // text1.paddingTop = text1.paddingBottom = text1.paddingLeft = text1.paddingRight = '20px';
        var createLabel = function (mesh) {
          label.background = 'black';
          // label.height = '30px';
          label.alpha = 0.85;
          // label.width = '400px';
          label.cornerRadius = 20;
          label.thickness = 1;
          label.linkOffsetY = 0;//90;
          advancedTexture.addControl(label);
          label.linkWithMesh(mesh);

          // var text1 = new BABYLON.GUI.TextBlock;
          text1.resizeToFit = true;
          text1.text = mesh.name;
          text1.color = "white";
          text1.onLinesReadyObservable.add(function() {
            // Manually set the rectangle size.
            // We don't use label.adaptWidth/HeightToChildren() because
            // we want padding around the text, and setting paddingTop/Bottom/Left/Right()
            // doesn't seem to do the same as what we're doing here.
            //
            console.log(`observe "${text1.text}" lines wxh ${text1.width} ${text1.height}`);
            const w = parseFloat(text1.width.slice(0, -2)); // Remove the trailing 'px';
            const h = parseFloat(text1.height.slice(0, -2)); // Remove the trailing 'px';
            console.log(`width=${w}`);
            label.width = `${w+20}px`;
            label.height = `${h+20}px`;
            const hasText = text1.text!=='';
            label.isVisible = hasText;
            text1.isVisible = hasText;
          });
          label.addControl(text1)
        };

        scene.clearColor = new BABYLON.Color4(...data.background_color);

        data.camera.eye[2] = -data.camera.eye[2];
        data.camera.centre[2] = -data.camera.centre[2];
        data.camera.up[2] = -data.camera.up[2];
        camera.position = new BABYLON.Vector3(...data.camera.eye);
        camera.target = new BABYLON.Vector3(...data.camera.centre);
        camera.upVector = new BABYLON.Vector3(...data.camera.up);

        const NVX = Object.keys(data.vertex).length;
        console.log('Vertices: %s', NVX);
        console.log('Atlas   : %s', data.sprite_atlas)

        const spriteMgr = new BABYLON.SpriteManager('vxMgr', data.sprite_atlas.name, NVX, 256, scene);
        spriteMgr.isPickable = true;
        console.log('spriteMgr:', spriteMgr);
        console.log('texture: ', spriteMgr.texture.getBaseSize());

        // Labels are implemented by creating a single label, then setting
        // the text and position when OnPointerOverTrigger happens.
        // We can't attach a label to a SpriteManager, so create a dummy label mesh.
        // Use the simplest mesh; we aren't going to see it.
        //
        const labelMesh = BABYLON.Mesh.CreateGround('labelMesh1', 0, 0, 0, scene);
        labelMesh.setEnabled(false);
        // labelMesh.position.x = 0;
        // labelMesh.position.y = 0;
        // labelMesh.color = BABYLON.Color4(0, 0, 0, 0);

        const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        advancedTexture.useInvalidateRectOptimization = false;
        createLabel(labelMesh);
        text1.text = '';
        label.isVisible = false;
        text1.isVisible = false;

        const w = data.sprite_atlas.width;
        const h = data.sprite_atlas.height;

        for(let [i, vx] of Object.entries(data.vertex)) {
          const sprite = new BABYLON.Sprite(i, spriteMgr);
          sprite.position.x = vx.x;
          sprite.position.y = vx.y;
          sprite.position.z = -vx.z;
          sprite.cellIndex = vx.fg_icon_index;
          sprite.size = 2.5 * vx.nradius; // make the node sizees approximate Constellation.

          // We need to pass the x,y of the background icon to the shaders.
          // We don't use angle, so let's put them in there by abusing maths.
          // 67108864 = 2**26.
          //
          sprite.angle = Math.trunc(vx.bg_icon_index/w*67108864) + vx.bg_icon_index/h;
          sprite.color = new BABYLON.Color4(...vx.color);

          // https://doc.babylonjs.com/how_to/how_to_use_actions
          //
          sprite.isPickable = true;
          sprite.actionManager = new BABYLON.ActionManager(scene);
          sprite.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPointerOverTrigger, event=>{
            console.log('Over '+event.source.name);
            // text1.text = event.source.name;
            text1.text = data.vertex[event.source.name].Label;
            labelMesh.position.x = event.source.position.x;
            labelMesh.position.y = event.source.position.y;
            labelMesh.position.z = event.source.position.z;
            console.log(`wxh ${text1.width} ${text1.height}`);
            label.isVisible = true;
            text1.isVisible = true;
            }));
          sprite.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPointerOutTrigger, event=>{
            console.log('Out '+event.source.name);
            text1.text = '';
            label.isVisible = false;
            text1.isVisible = false;
            }));
          sprite.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, event=>{console.log('Pick '+event.source.name);}));
        }

        const NTX = data.transaction.length;
        const lines = [];
        const lineColors = [];
        data.transaction.forEach(tx => {
          const s = data.vertex[tx['source.[id]']];
          const d = data.vertex[tx['destination.[id]']];
          const line = [new BABYLON.Vector3(s.x, s.y, -s.z), new BABYLON.Vector3(d.x, d.y, -d.z)];
          lines.push(line);

          const color = new BABYLON.Color4(...tx.color);
          lineColors.push([color, color]);
        });

        const liness = BABYLON.MeshBuilder.CreateLineSystem('liness', {lines: lines, colors:lineColors, useVertexAlpha:false, width:10}, scene);
      });
      //.catch(error => {console.log('Error:', error);});

      return scene;
    };

    const scene = createScene();

    // scene.registerBeforeRender(function() {
    // })

    // Register a render loop to repeatedly render the scene
    engine.runRenderLoop(function () {
      scene.render();
    });

    // Watch for browser/canvas resize events
    window.addEventListener('resize', function () {
      engine.resize();
    });
  </script>
  </body>

</html>