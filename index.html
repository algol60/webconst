<!DOCTYPE html>
<html>

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="icon" href="constellation.png">
    <title>Babylon graph from JSON</title>

    <style>
      html, body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }
    </style>

    <script src="js/babylon-4.1.0.js"></script>
  </head>

  <body>

  <canvas id="renderCanvas" touch-action="none"></canvas> //touch-action="none" for best results from PEP

  <script>
    'use strict';

    BABYLON.Effect.ShadersStore['spritesVertexShader'] = `
attribute vec4 position;
attribute vec4 options;
attribute vec2 inverts;
attribute vec4 cellInfo;
attribute vec4 color;

uniform mat4 view;
uniform mat4 projection;

varying vec2 vUV;
varying vec2 bgUV;
varying vec4 vColor;
#include<fogVertexDeclaration>
void main(void) {
  vec3 viewPos = (view*vec4(position.xyz, 1.0)).xyz;
  vec2 cornerPos;
  float angle = position.w;
  vec2 size = vec2(options.x,options.y);
  vec2 offset = options.zw;
  cornerPos = vec2(offset.x-0.5, offset.y-0.5)*size;

  // vec3 rotatedCorner;
  // rotatedCorner.x = cornerPos.x*cos(angle)-cornerPos.y*sin(angle);
  // rotatedCorner.y = cornerPos.x*sin(angle)+cornerPos.y*cos(angle);
  // rotatedCorner.z = 0.;

  vec3 rotatedCorner;
  rotatedCorner.x = cornerPos.x;
  rotatedCorner.y = cornerPos.y;
  rotatedCorner.z = 0.;

  viewPos += rotatedCorner;
  gl_Position = projection*vec4(viewPos,1.0);

  vColor = color;

  vec2 uvOffset = vec2(abs(offset.x-inverts.x), abs(1.0-offset.y-inverts.y));
  vec2 uvPlace = cellInfo.xy;
  vec2 uvSize = cellInfo.zw;
  vUV.x = uvPlace.x+uvSize.x*uvOffset.x;
  vUV.y = uvPlace.y+uvSize.y*uvOffset.y;

  // Extract the background icon position from angle.
  // All of the icons are the same size, so we can reuse size and offset.
  //
  vec2 bgPlace = vec2(trunc(angle)/67108864.0, angle - trunc(angle));
  bgUV.x = bgPlace.x + uvSize.x*uvOffset.x;
  bgUV.y = bgPlace.y + uvSize.y*uvOffset.y;

  #ifdef FOG
  vFogDistance = viewPos;
  #endif
}
  `;

    BABYLON.Effect.ShadersStore['spritesPixelShader']  =  `
uniform bool alphaTest;
varying vec4 vColor;

varying vec2 vUV;
varying vec2 bgUV;
uniform sampler2D diffuseSampler;

#include<fogFragmentDeclaration>

void main(void) {
  vec4 color = texture2D(diffuseSampler, vUV);
  if(true) // (alphaTest)
  {
    if (color.a<0.95)
    {
      vec4 bgColor = texture2D(diffuseSampler,bgUV);
      if(bgColor.a<0.95) discard;
      // bgColor.a = 1.0;
      color = bgColor * vColor;
    }
  }
  // color *= vColor;

  #include<fogFragment>

  gl_FragColor=color;
}
    `;

    const canvas = document.getElementById('renderCanvas'); // Get the canvas element
    const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
    console.log('Maximum texture size:', engine.getCaps().maxTextureSize);

    const createScene = function () {

      // scene and lights
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3(0x1b/255, 0x1e/255, 0x24/255);
      const camera = new BABYLON.ArcRotateCamera('camera1', 0, 0, 0, new BABYLON.Vector3(0, 0, -0), scene);
      camera.wheelPrecision = 50;
      camera.setPosition(new BABYLON.Vector3(0, 50, -300));
      camera.attachControl(canvas, true);
      const light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(1, 1, 0), scene);
      light.intensity = 0.9;
      const pl = new BABYLON.PointLight('pl', new BABYLON.Vector3(0, 0, 0), scene);
      // pl.diffuse = new BABYLON.Color3(1, 1, 1);
      // pl.specular = new BABYLON.Color3(0.5, 0.2, 0.2);
      pl.intensity = 0.75;

      fetch('sphere-graph.json')
      .then(response => response.json())
      .then(data => {
        const NVX = Object.keys(data.vertex).length;
        console.log('Vertices: %s', NVX);
        console.log('Atlas   : %s', data.sprite_atlas)

        const spriteMgr = new BABYLON.SpriteManager('vxMgr', data.sprite_atlas.name, NVX, 256, scene);
        console.log('spriteMgr:', spriteMgr);
        console.log('texture: ', spriteMgr.texture.getBaseSize());

        const w = data.sprite_atlas.width;
        const h = data.sprite_atlas.height;

        for(let [i, vx] of Object.entries(data.vertex)) {
          const sprite = new BABYLON.Sprite('sprite_'+i, spriteMgr);
          sprite.position.x = vx.x;
          sprite.position.y = vx.y;
          sprite.position.z = -vx.z;
          sprite.cellIndex = vx.fg_icon_index;
          sprite.size = 2.5 * vx.nradius; // make the node sizees approximate Constellation.

          // We need to pass the x,y of the background icon to the shaders.
          // We don't use angle, so let's put them in there by abusing maths.
          // 67108864 = 2**26.
          //
          sprite.angle = Math.trunc(vx.bg_icon_index/w*67108864) + vx.bg_icon_index/h;
          sprite.color = new BABYLON.Color4(...vx.color);
        }

        const NTX = data.transaction.length;
        const lines = [];
        const lineColors = [];
        data.transaction.forEach(tx => {
          const s = data.vertex[tx['source.[id]']];
          const d = data.vertex[tx['destination.[id]']];
          const line = [new BABYLON.Vector3(s.x, s.y, -s.z), new BABYLON.Vector3(d.x, d.y, -d.z)];
          lines.push(line);

          const color = new BABYLON.Color4(...tx.color);
          lineColors.push([color, color]);
        });

        const liness = BABYLON.MeshBuilder.CreateLineSystem('liness', {lines: lines, colors:lineColors, useVertexAlpha:false}, scene);
      })
      .catch(error => {console.log('Error:', error);});

      return scene;
    };

    const scene = createScene(); //Call the createScene function

    // Register a render loop to repeatedly render the scene
    engine.runRenderLoop(function () {
      scene.render();
    });

    // Watch for browser/canvas resize events
    window.addEventListener('resize', function () {
      engine.resize();
    });
  </script>
  </body>

</html>