<!DOCTYPE html>
<html>

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="icon" href="constellation.png">
    <title>Babylon graph from JSON</title>

    <style>
      html, body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }
    </style>

    <script src="js/babylon-4.1.0.js"></script>
    <script src="js/babylon.gui.min.js"></script>
</head>

  <body>

  <canvas id="renderCanvas" touch-action="none"></canvas> //touch-action="none" for best results from PEP

  <script>
    'use strict';

    const node_spritesVertexShader = `
attribute vec4 position;
attribute vec4 options;
attribute vec2 inverts;
attribute vec4 cellInfo;
attribute vec4 color;

uniform mat4 view;
uniform mat4 projection;

varying vec2 vUV;
varying vec2 bgUV;
varying vec4 vColor;
#include<fogVertexDeclaration>
void main(void) {
  vec3 viewPos = (view*vec4(position.xyz, 1.0)).xyz;
  vec2 cornerPos;
  float angle = position.w;
  vec2 size = vec2(options.x,options.y);
  vec2 offset = options.zw;
  cornerPos = vec2(offset.x-0.5, offset.y-0.5)*size;

  // vec3 rotatedCorner;
  // rotatedCorner.x = cornerPos.x*cos(angle)-cornerPos.y*sin(angle);
  // rotatedCorner.y = cornerPos.x*sin(angle)+cornerPos.y*cos(angle);
  // rotatedCorner.z = 0.;

  vec3 rotatedCorner;
  rotatedCorner.x = cornerPos.x;
  rotatedCorner.y = cornerPos.y;
  rotatedCorner.z = 0.;

  viewPos += rotatedCorner;
  gl_Position = projection*vec4(viewPos,1.0);

  vColor = color;

  vec2 uvOffset = vec2(abs(offset.x-inverts.x), abs(1.0-offset.y-inverts.y));
  vec2 uvPlace = cellInfo.xy;
  vec2 uvSize = cellInfo.zw;
  vUV.x = uvPlace.x+uvSize.x*uvOffset.x;
  vUV.y = uvPlace.y+uvSize.y*uvOffset.y;

  // Extract the background icon position from angle.
  // All of the icons are the same size, so we can reuse size and offset.
  //
  vec2 bgPlace = vec2(trunc(angle)/67108864.0, angle - trunc(angle));
  bgUV.x = bgPlace.x + uvSize.x*uvOffset.x;
  bgUV.y = bgPlace.y + uvSize.y*uvOffset.y;

  #ifdef FOG
  vFogDistance = viewPos;
  #endif
}
  `;

    const node_spritesPixelShader =  `
uniform bool alphaTest;
varying vec4 vColor;

varying vec2 vUV;
varying vec2 bgUV;
uniform sampler2D diffuseSampler;

#include<fogFragmentDeclaration>

void main(void) {
  vec4 color = texture2D(diffuseSampler, vUV);
  if(true) // (alphaTest)
  {
    if (color.a<0.95)
    {
      vec4 bgColor = texture2D(diffuseSampler,bgUV);
      if(bgColor.a<0.95) discard;
      // bgColor.a = 1.0;
      color = bgColor * vColor;
    }
  }
  // color *= vColor;

  #include<fogFragment>

  gl_FragColor=color;
}
    `;

    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true);
    console.log('Maximum texture size:', engine.getCaps().maxTextureSize);

    const createScene = function () {
      const SIZE = 2.5;

      // scene and lights
      const scene = new BABYLON.Scene(engine);
      // scene.clearColor = new BABYLON.Color3(0x1b/255, 0x1e/255, 0x24/255);
      const camera = new BABYLON.ArcRotateCamera('camera1', 0, 0, 0, new BABYLON.Vector3(0, 0, -0), scene);
      camera.wheelPrecision = 50;
      // camera.setPosition(new BABYLON.Vector3(0, 50, -300));

      camera.attachControl(canvas, true);
      scene.activeCamera.panningSensibility = 50;

      const light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(1, 1, 0), scene);
      light.intensity = 0.9;
      const pl = new BABYLON.PointLight('pl', new BABYLON.Vector3(0, 0, 0), scene);
      // pl.diffuse = new BABYLON.Color3(1, 1, 1);
      // pl.specular = new BABYLON.Color3(0.5, 0.2, 0.2);
      pl.intensity = 0.75;

      fetch('sphere-graph.json')
      .then(response => response.json())
      .then(data => {

        // Create a Rectangle containing a TextBlock to make a pretty node label.
        // Doing labels like Constellation is nasty and complicated.
        // Instead, we'll use BABYLON.GUI to create a single TextBlock and
        // make it visible when the cursor hovers over a node, resizing the
        // Rectangle to fix the text as we go..
        // To do this, we need to attach the Rectangle to a dummy mesh.
        //
        const label = new BABYLON.GUI.Rectangle('node label');
        label.isPointerBlocker = false;
        // label.adaptWidthToChildren = true;
        // label.adaptHeightToChildren = true;
        const text1 = new BABYLON.GUI.TextBlock('node text');
        text1.isPointerBlocker = false;
        // text1.paddingTop = text1.paddingBottom = text1.paddingLeft = text1.paddingRight = '20px';

        var createLabel = function (mesh) {
          label.background = 'black';
          // label.height = '30px';
          label.alpha = 0.85;
          // label.width = '400px';
          label.cornerRadius = 20;
          label.thickness = 1;
          label.linkOffsetY = 0;//90;
          advancedTexture.addControl(label);
          label.linkWithMesh(mesh);

          // var text1 = new BABYLON.GUI.TextBlock;
          text1.resizeToFit = true;
          text1.text = mesh.name;
          text1.color = 'white';
          text1.onLinesReadyObservable.add(function() {
            // Manually set the rectangle size.
            // We don't use label.adaptWidth/HeightToChildren() because
            // we want padding around the text, and setting paddingTop/Bottom/Left/Right()
            // doesn't seem to do the same as what we're doing here.
            //
            const w = parseFloat(text1.width.slice(0, -2)); // Remove the trailing 'px';
            const h = parseFloat(text1.height.slice(0, -2)); // Remove the trailing 'px';
            label.width = `${w+20}px`;
            label.height = `${h+20}px`;
            const hasText = text1.text!=='';
            label.isVisible = hasText;
            text1.isVisible = hasText;
          });
          label.addControl(text1)
        };

        scene.clearColor = new BABYLON.Color4(...data.background_color);

        data.camera.eye[2] = -data.camera.eye[2];
        data.camera.centre[2] = -data.camera.centre[2];
        data.camera.up[2] = -data.camera.up[2];
        camera.position = new BABYLON.Vector3(...data.camera.eye);
        camera.target = new BABYLON.Vector3(...data.camera.centre);
        camera.upVector = new BABYLON.Vector3(...data.camera.up);
        // camera.alpha = 0.002;

        const NVX = Object.keys(data.vertex).length;
        console.log('Vertices: %s', NVX);
        console.log('Atlas   : %s', data.sprite_atlas)

        const createBlazes = function(vertices) {
          // Set up blazes (if there are any).
          //
          const vxs = Object.values(vertices).filter(vx => vx.blaze!==null);
          const nBlazes = vxs.length;

          // const blazeMesh = BABYLON.MeshBuilder.CreateBox("blaze", {size: 1}, scene);
          const blazeMesh = BABYLON.MeshBuilder.CreateCylinder('blazes', {
            diameterTop:0.0,
            tessellation:4
          }, scene);
          blazeMesh.alwaysSelectAsActiveMesh = true;
          blazeMesh.isVisible = false;

          let colorData = new Float32Array(4 * (nBlazes+1));
          for(let ix=0; ix<nBlazes; ix++) {
              colorData[ix * 4 + 0] = vxs[ix].blaze.color[0];
              colorData[ix * 4 + 1] = vxs[ix].blaze.color[1];
              colorData[ix * 4 + 2] = vxs[ix].blaze.color[2];
              colorData[ix * 4 + 3] = vxs[ix].blaze.color[3];
          }

          const buffer = new BABYLON.VertexBuffer(engine, colorData, BABYLON.VertexBuffer.ColorKind, false, false, 4, true);
          blazeMesh.setVerticesBuffer(buffer);

          blazeMesh.material = new BABYLON.StandardMaterial('blaze_mat');
          // blazeMesh.material.disableLighting = true;
          blazeMesh.material.emissiveColor = BABYLON.Color3.White();

          const toRadians = angle => angle * (Math.PI / 180);
          const offset = Math.sqrt(2+SIZE); // offset by height of cylinder + size of node
          for(let ix=0; ix<nBlazes; ix++) {
              const instance = blazeMesh.createInstance('blaze' + ix);
              const zangle = toRadians(vxs[ix].blaze.angle)
              instance.rotation.x = Math.PI;
              instance.rotation.z = zangle;

              // The offset has to take the angle into account.
              //
              instance.position.x = vxs[ix].x+offset*Math.sin(zangle);
              instance.position.y = vxs[ix].y+offset*Math.cos(zangle);
              instance.position.z = vxs[ix].z;
              instance.alwaysSelectAsActiveMesh = true;
          }
        };

        createBlazes(data.vertex);

        BABYLON.Effect.ShadersStore['spritesVertexShader'] = node_spritesVertexShader;
        BABYLON.Effect.ShadersStore['spritesPixelShader']  = node_spritesPixelShader;
        const spriteMgr = new BABYLON.SpriteManager('vxMgr', data.sprite_atlas.name, NVX, 256, scene);
        spriteMgr.isPickable = true;
        console.log('spriteMgr:', spriteMgr);
        console.log('texture: ', spriteMgr.texture.getBaseSize());

        // Labels are implemented by creating a single label, then setting
        // the text and position when OnPointerOverTrigger happens.
        // We can't attach a label to a SpriteManager, so create a dummy label mesh.
        // Use the simplest mesh; we aren't going to see it.
        //
        const labelMesh = BABYLON.Mesh.CreateGround('labelMesh1', 0, 0, 0, scene);
        labelMesh.setEnabled(false);
        // labelMesh.position.x = 0;
        // labelMesh.position.y = 0;
        // labelMesh.color = BABYLON.Color4(0, 0, 0, 0);

        const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        advancedTexture.useInvalidateRectOptimization = false;
        createLabel(labelMesh);
        text1.text = '';
        label.isVisible = false;
        text1.isVisible = false;

        const w = data.sprite_atlas.width;
        const h = data.sprite_atlas.height;

        for(let [i, vx] of Object.entries(data.vertex)) {
          const sprite = new BABYLON.Sprite(i, spriteMgr);
          sprite.position.x = vx.x;
          sprite.position.y = vx.y;
          sprite.position.z = -vx.z;
          sprite.cellIndex = vx.fg_icon_index;
          sprite.size = SIZE * vx.nradius; // make the node sizees approximate Constellation.

          // We need to pass the x,y of the background icon to the shaders.
          // We don't use angle, so let's put them in there by abusing maths.
          // 67108864 = 2**26.
          //
          sprite.angle = Math.trunc(vx.bg_icon_index/w*67108864) + vx.bg_icon_index/h;
          sprite.color = new BABYLON.Color4(...vx.color);

          // https://doc.babylonjs.com/how_to/how_to_use_actions
          //
          sprite.isPickable = true;
          sprite.actionManager = new BABYLON.ActionManager(scene);
          sprite.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPointerOverTrigger, event=>{
            console.log('Over '+event.source.name);
            text1.text = data.vertex[event.source.name].Label;
            labelMesh.position.x = event.source.position.x;
            labelMesh.position.y = event.source.position.y;
            labelMesh.position.z = event.source.position.z;
            console.log(`wxh ${text1.width} ${text1.height}`);
            label.isVisible = true;
            text1.isVisible = true;
            }));
          sprite.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPointerOutTrigger, event=>{
            console.log('Out '+event.source.name);
            text1.text = '';
            label.isVisible = false;
            text1.isVisible = false;
            }));
          sprite.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, event=>{console.log('Pick '+event.source.name);}));
        }

        // Lines.
        //
        const NTX = data.transaction.length;
        const lines = [];
        const lineColors = [];
        data.transaction.forEach(tx => {
          const s = data.vertex[tx['sid_']];
          const d = data.vertex[tx['did_']];
          const line = [new BABYLON.Vector3(s.x, s.y, -s.z), new BABYLON.Vector3(d.x, d.y, -d.z)];
          lines.push(line);

          const color = new BABYLON.Color4(...tx.color);
          lineColors.push([color, color]);
        });

        const liness = BABYLON.MeshBuilder.CreateLineSystem('liness', {lines: lines, colors:lineColors, useVertexAlpha:false, width:10}, scene);

        // Direction indicators.
        //
        const createDirections = function(transactions) {
          const arrows = []
          transactions.forEach(tx => {
            const dirs = tx.directions;
            if(dirs.includes('>')) {
              arrows.push({sid_:tx.sid_, did_:tx.did_, color: tx.color})
            }
            if(dirs.includes('<')) {
              arrows.push({sid_:tx.did_, did_:tx.sid_, color: tx.color})
            }
          });

          const nArrows = arrows.length;
          const arrowMesh = BABYLON.MeshBuilder.CreateCylinder('arrowheads', {
            height: 0.5,
            diameterBottom: 0.25,
            diameterTop:0.0,
            tessellation:3
          }, scene);
          arrowMesh.alwaysSelectAsActiveMesh = true;
          arrowMesh.isVisible = false;

          let colorData = new Float32Array(4 * (nArrows+1));
          for(let ix=0; ix<nArrows; ix++) {
              colorData[ix * 4 + 0] = arrows[ix].color[0];
              colorData[ix * 4 + 1] = arrows[ix].color[1];
              colorData[ix * 4 + 2] = arrows[ix].color[2];
              colorData[ix * 4 + 3] = arrows[ix].color[3];
          }

          const buffer = new BABYLON.VertexBuffer(engine, colorData, BABYLON.VertexBuffer.ColorKind, false, false, 4, true);
          arrowMesh.setVerticesBuffer(buffer);

          arrowMesh.material = new BABYLON.StandardMaterial('arrow_mat');
          // blazeMesh.material.disableLighting = true;
          arrowMesh.material.emissiveColor = BABYLON.Color3.White();

          const vxs = data.vertex;
          const toRadians = angle => angle * (Math.PI / 180);
          const offset = 1.25;//Math.sqrt(SIZE); // offset by height of cylinder + size of node
          for(let ix=0; ix<nArrows; ix++) {
              const instance = arrowMesh.createInstance('arrow' + ix);

              // Figure out the offset of the arrowhead from the node.
              //
              const sv = arrows[ix].sid_;
              const dv = arrows[ix].did_;
              const hypot = Math.hypot(vxs[sv].x-vxs[dv].x, vxs[sv].y-vxs[dv].y, vxs[sv].z-vxs[dv].z);
              const ox = offset*(vxs[sv].x-vxs[dv].x)/hypot;
              const oy = offset*(vxs[sv].y-vxs[dv].y)/hypot;
              const oz = offset*(vxs[sv].z-vxs[dv].z)/hypot;

              instance.position.x = vxs[dv].x+ox;
              instance.position.y = vxs[dv].y+oy;
              instance.position.z = -vxs[dv].z-oz;

              // Make the arrowhead look at the destination node.
              // The pitch and roll make the cylinder line up in the correct direction.
              //
              instance.lookAt(new BABYLON.Vector3(vxs[dv].x, vxs[dv].y, -vxs[dv].z), 0, -Math.PI/2, Math.PI);
              instance.alwaysSelectAsActiveMesh = true;
          }
        };

        createDirections(data.transaction);
      });
      //.catch(error => {console.log('Error:', error);});

      // scene.freezeActiveMeshes();

      return scene;
    };

    const scene = createScene();

    // scene.registerBeforeRender(function() {
    // })

    // Register a render loop to repeatedly render the scene
    engine.runRenderLoop(function () {
      scene.render();
    });

    // Watch for browser/canvas resize events
    window.addEventListener('resize', function () {
      engine.resize();
    });
  </script>
  </body>

</html>