<!DOCTYPE html>
<html>

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Babylon random uniform sprite map</title>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>

        <script src="js/babylon-4.1.0.js"></script>
    </head>

   <body>

    <canvas id="renderCanvas" touch-action="none"></canvas> //touch-action="none" for best results from PEP

    <script>
        'use strict';

        var canvas = document.getElementById("renderCanvas"); // Get the canvas element
        var engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

        var createScene = function () {
            const N = 10000;
            const NLINES = 200;

            // scene and lights
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0x1b/255, 0x1e/255, 0x24/255);
            var camera = new BABYLON.ArcRotateCamera("camera1",  0, 0, 0, new BABYLON.Vector3(0, 0, -0), scene);
            camera.wheelPrecision = 50;
            camera.setPosition(new BABYLON.Vector3(0, 50, -300));
            camera.attachControl(canvas, true);
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 0), scene);
            light.intensity = 0.9;
            var pl = new BABYLON.PointLight("pl", new BABYLON.Vector3(0, 0, 0), scene);
            // pl.diffuse = new BABYLON.Color3(1, 1, 1);
            // pl.specular = new BABYLON.Color3(0.5, 0.2, 0.2);
            pl.intensity = 0.75;

            const lines = [];
            const lineColors = [];
            let x0 = -1, y0 = -1, z0=-1;

            const spriteManager = new BABYLON.SpriteManager('constManager', 'uniform.png', N, 256, scene);

            const side = Math.sqrt(N);
            for(let i=0; i<N; i++) {
                const sprite = new BABYLON.Sprite('sprite', spriteManager);
                sprite.cellIndex = i % 4;
                // sprite.size = 1;
                const x = (Math.random()-0.5) * side;
                const y = (Math.random()-0.5) * side;
                const z = (Math.random()-0.5) * side;
                sprite.position.x = x;
                sprite.position.y = y;
                sprite.position.z = z;
                if(i<NLINES) {
                    const color = new BABYLON.Color4(Math.random(), Math.random(), Math.random(), 1);
                    lineColors.push([color, color]);
                }
                if(i>0 && i<NLINES) {
                    const line = [new BABYLON.Vector3(x0, y0, z0), new BABYLON.Vector3(x, y, z)];
                    lines.push(line);
                }
                if(i%(NLINES/10)==0) {
                x0 = x;
                y0 = y;
                z0 = z;
                }
            }

            const liness = BABYLON.MeshBuilder.CreateLineSystem('liness', {lines: lines, colors:lineColors, useVertexAlpha:false}, scene);

            return scene;
            };

        var scene = createScene(); //Call the createScene function

        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {
                scene.render();
        });

        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine.resize();
        });
    </script>

   </body>

</html>
